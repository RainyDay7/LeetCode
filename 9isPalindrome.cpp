class Solution {
public:
    bool isPalindrome(int x) {
        //1.所有的负数都不是回文数

        //2如果整数的最后一位是00 ，那么必须这个数为0的时候才是回文数
        if(x<0 || x%10==0&&x!=0) {
            return false;
        }

        int revertNumber=0;
        while(x>revertNumber){
            revertNumber = revertNumber*10+x%10;
            x/=10;
        }
        return x==revertNumber||x==revertNumber/10;
    }
};
/*
  为了避免产生溢出问题，我们可以只逆序整数的一半。回文数的后半部分的逆序应该和回文数的前半部分相同。
      举个例子，如果输入的是“1221”，我们可以将“1221”的后半部分从“21”逆序为“12”，并与“1221”的前半部分进行比较。
      如果相同，那么就是一个回文数。
      重复这样的过程，直到这个整数的中间位置。
      然后，通过“1*10+2=12”就能得到整数后半部分的逆序了。
      现在问题的关键是，我们如何知道，我们已经到了这个整数的中间位置了。
      当逆序后的数的值大于原来的值的时候，就到了这个整数的中间位置了。
*/
